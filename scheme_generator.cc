// Copyright (c) 2019 Indigo BioAutomation, Inc.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <string>

using namespace std;
using namespace google::protobuf;
using namespace google::protobuf::compiler;

class SchemeGenerator : public CodeGenerator {
  virtual bool Generate(const FileDescriptor* file,
                        const string &parameter,
                        GeneratorContext* generator_context,
                        string* error) const;
};

static void GenerateMessage(const Descriptor* desc, io::Printer* printer);

static string GetOutputFilename(const string &proto_file) {
  return proto_file.substr(0, proto_file.find_last_of(".")) + "_pb.ss";
}

template <typename DescriptorT>
static string QualifiedName(const DescriptorT* desc) {
  string name = desc->name();
  for (const Descriptor* current = desc->containing_type();
       current != NULL; current = current->containing_type()) {
    name = current->name() + "." + name;
  }
  return name;
}

static void GenerateEnum(const EnumDescriptor* desc, io::Printer* printer) {
  printer->Print(
    "\n(define-enum $name$",
    "name", QualifiedName(desc));
  printer->Indent();
  for (auto i = 0; i < desc->value_count(); i++) {
    auto vdesc = desc->value(i);
    printer->Print(
      "\n($name$ $value$)",
      "name", vdesc->name(),
      "value", to_string(vdesc->number()));
  }
  printer->Outdent();
  printer->Print(")\n");
}

static string TypeName(const FieldDescriptor* desc) {
  switch (desc->type()) {
  case FieldDescriptor::Type::TYPE_MESSAGE:
    return "(message " + QualifiedName(desc->message_type()) + ")";
  case FieldDescriptor::Type::TYPE_ENUM:
    return "(enum " + QualifiedName(desc->enum_type()) + ")";
  case FieldDescriptor::Type::TYPE_GROUP:
    return "(group " + QualifiedName(desc->message_type()) + ")";
  default:
    return desc->type_name();
  }
}

static void GenerateMessage(const Descriptor* desc, io::Printer* printer) {
  if (desc->options().has_map_entry())
    return;
  printer->Print(
    "\n(define-message $name$",
    "name", QualifiedName(desc));
  printer->Indent();
  for (auto i = 0; i < desc->field_count(); i++) {
    auto fdesc = desc->field(i);
    auto oneof = fdesc->containing_oneof();
    if (fdesc->is_map())
      printer->Print(
        "\n($name$ (map $key$ $value$) $index$)",
        "name", fdesc->name(),
        "key", TypeName(fdesc->message_type()->FindFieldByNumber(1)),
        "value", TypeName(fdesc->message_type()->FindFieldByNumber(2)),
        "index", to_string(fdesc->number()));
    else if (fdesc->is_repeated())
      printer->Print(
        "\n($name$ (repeated $type$) $index$)",
        "name", fdesc->name(),
        "type", TypeName(fdesc),
        "index", to_string(fdesc->number()));
    else
      printer->Print(
        "\n($name$ $type$ $index$)",
        "name", fdesc->name(),
        "type", TypeName(fdesc),
        "index", to_string(fdesc->number()));
  }
  printer->Outdent();
  printer->Print(")\n");
  for (auto i = 0; i < desc->nested_type_count(); i++)
    GenerateMessage(desc->nested_type(i), printer);
  for (auto i = 0; i < desc->enum_type_count(); i++)
    GenerateEnum(desc->enum_type(i), printer);
}

static bool GenerateFile(const FileDescriptor* file, io::Printer* printer,
                         string* error) {
  printer->Print(
    ";;; Generated by the protocol buffer compiler. DO NOT EDIT!\n"
    ";;; source: $filename$\n",
    "filename", file->name());
  for (auto i = 0; i < file->dependency_count(); i++)
    printer->Print(";;; include: $filename$\n", "filename", file->dependency(i)->name().c_str());
  for (auto i = 0; i < file->message_type_count(); i++)
    GenerateMessage(file->message_type(i), printer);
  for (auto i = 0; i < file->enum_type_count(); i++)
    GenerateEnum(file->enum_type(i), printer);
  return true;
}

bool SchemeGenerator::Generate(const FileDescriptor* file,
                               const string &parameter,
                               GeneratorContext* generator_context,
                               string* error) const {
  unique_ptr<io::ZeroCopyOutputStream> output(
    generator_context->Open(GetOutputFilename(file->name())));
  io::Printer printer(output.get(), '$');

  return GenerateFile(file, &printer, error);
}

int main(int argc, char* argv[]) {
  SchemeGenerator scheme_gen;
  return PluginMain(argc, argv, &scheme_gen);
}
